# *Project 12: verify the above pitfalls with proof-of-concept code  

## 实验内容  

实现在SM2签名下由已知的泄露的k退出私钥d。  


## 算法分析  

算法设计分为以下几步：

**1. SM2曲线参数设置**：定义了椭圆曲线SM2的参数A、B、P、G、N以及基点G的横纵坐标G_X和G_Y。  

**2. 椭圆曲线点运算**：实现了椭圆曲线上的点加法和倍乘运算函数。  

    elliptic_add函数实现椭圆曲线上不同点的加法运算。  

    elliptic_double函数实现同一点的加法运算（即点的自加运算）。  

    elliptic_multiply函数实现椭圆曲线上的点倍乘运算。  

**3. 生成预计算值Z_A**：precomputation函数用于生成预计算值Z_A。将必要信息转化为字符串，然后级联这些字符串，进行SM3哈希计算得到Z_A。  

**4. 签名生成**：sign函数用于生成签名。首先计算消息m*，然后进行SM3哈希计算得到e。从[0, N)范围内随机选择一个数k，并计算椭圆曲线点`(x_1, y_1) = [k]G`。计算签名`r=(e+x_1)mod n`和`s=((1+private_key)^(-1)⋅(k−r⋅private_key))mod n`。  

**5. 验证签名**：verify函数用于验证签名的有效性。首先重新计算消息m*，然后进行SM3哈希计算得到e。利用签名中的r和s以及预计算值Z_A计算点坐标`(x1, y1)`和`(t⋅public_key)`。然后对这两个点进行椭圆曲线上的点加法运算，得到新的点，计算`R=(e+x1)mod n`。最后，判断R是否等于签名中的r，若相等，则验证通过，否则不通过。  

**6. 泄露k计算私钥d**：k_to_d函数用于计算私钥d，其中k为已知的随机数，r和s为签名中的值。根据SM2签名算法中的s与k的关系`d=(r+s)^(-1)*(k-s)`，通过已知的k、r、s计算出私钥d。  

**7. 生成公私钥对**：generate_key函数用于生成SM2的公私钥对。私钥为一个大整数，通过随机生成得到。公钥是椭圆曲线上的点，通过将私钥和基点G进行倍乘运算得到。

## 测试方法  

将sm2_sig.py文件放到项目中运行即可。  


## 实验结果展示 

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/4fda6e25-e12c-4d82-b7d0-77ed88d137f1)

如上图所示，运行时间约为4.9989 ms。  

