# *Project 22: research report on MPT  

# MPT研究报告  

## 摘要  

&ensp;&ensp;&ensp;&ensp;**Merkle Patricia Trie**（**MPT**）是一种用于高效存储和验证数据的数据结构，广泛应用于区块链和分布式数据库等领域。本研究报告对MPT进行了深入的研究和探讨。首先，我们介绍了MPT的背景和概念，包括其发展历史和用途。然后，我们详细讨论了MPT的结构和操作原理，并与传统的Merkle树进行了对比。接着，我们探讨了MPT在区块链技术中的应用，以及其在提高数据验证效率和降低存储空间成本方面的优势。最后，我们总结了MPT的优缺点，并展望了未来对MPT改进的研究方向。  

## 目录  

1.  引言  
1.1  背景  
2. Merkle Patricia Trie概述  
2.1 Merkle树基本概念  
2.2 Patricia Trie介绍  
2.3 Merkle Patricia Trie结合  
3. MPT结构和操作原理  
3.1 节点类型  
3.2 编码和哈希  
3.3 具体操作  
4. MPT在区块链中的应用  
4.1 以太坊中的MPT  
4.2 区块链状态存储  
4.3 交易存储  
4.4 其他应用领域  
5. MPT的优势和挑战  
5.1 优势  
5.2 挑战  
6. 未来展望  
7. 结论  
8. 参考文献  

## 1.引言
### 1.1背景  

&ensp;&ensp;&ensp;&ensp;随着分布式系统和区块链技术的发展，对于高效存储和验证数据的需求日益增长。传统的数据结构如哈希表和平衡二叉树虽然在某些场景下表现良好，但在存储大量数据和进行数据验证时往往面临性能瓶颈。为了解决这些问题，Merkle Patricia Trie（MPT）作为一种创新的数据结构应运而生。  

&ensp;&ensp;&ensp;&ensp;Merkle Patricia Trie是对Merkle树和Patricia Trie两种数据结构的融合，结合了它们的优势，能够在高效存储和验证数据的同时，降低存储空间和计算成本。其在区块链技术中的应用尤为广泛，尤其是在以太坊等智能合约平台中，MPT被用来存储状态和交易信息，提供了可靠的数据验证手段。  

## 2.Merkle Patricia Trie概述  

### 2.1 Merkle树基本概念  

&ensp;&ensp;&ensp;&ensp;**Merkle树**是基于哈希的二叉树结构，用于证明存储在块中的交易数据的完整性。其中每个叶子节点包含数据块的哈希值，而每个非叶子节点是其子节点的哈希值的哈希（通常使用加密哈希函数，如SHA-256）。这种树状结构使得整个数据集形成一个高效的可验证数据结构。通过验证根节点哈希，我们可以快速验证数据是否在树中存在或是否被篡改。  

该树的具体形态如下：  

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/034e0a29-0a82-4383-8927-3b651d070e4e)

&ensp;&ensp;&ensp;&ensp;一般的，这就是区块中交易部分的布局方式，这里的根即为交易头。即该树的节点基于最下面的数据，一层一层地往上构建生成节点（`left child、right child`的哈希值）。  

### 2.2 Patricia Trie介绍  

&ensp;&ensp;&ensp;&ensp;**Patricia Trie**（**又称前缀树或字典树**）是一种特殊的Trie数据结构，用于高效地存储和检索键值对，是一种多叉树，其root节点不代表字符，除了根节点以外的所有节点每个都代表一个字符，并且从根节点遍历到任意一个节点，遍历到的所有节点代表的字符连起来为该路径代表的字符串，每个节点的子节点代表的字符串各自不相同。  

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/5e2c8292-c8e6-42d1-97ea-29d4a840e303)

&ensp;&ensp;&ensp;&ensp;由上图可以发现，与传统的二叉搜索树不同，Patricia Trie不是通过将每个键值对存储在一个单独的节点上，而是通过共享前缀的方式来压缩存储空间。这意味着键相似的项会共享相同的前缀路径，从而降低了存储需求。Patricia Trie支持高效的查找、插入和删除操作，使其在存储大量数据时表现优越。  

### 2.3 Merkle Patricia Trie结合  

&ensp;&ensp;&ensp;&ensp;Merkle Patricia Trie将Merkle树和Patricia Trie结合起来，融合了两种数据结构的优势。在MPT中，每个键值对的键被编码为一个唯一的路径，该路径从树的根节点开始，并延伸到叶子节点。这种编码方式使得相似的键值对能够共享前缀路径，从而实现高效的存储和压缩。  

&ensp;&ensp;&ensp;&ensp;每个叶子节点包含一个键值对的哈希，而非键本身，这使得叶子节点具有固定长度，进一步简化了数据结构。非叶子节点仍然是其子节点的哈希的哈希值，从而构成Merkle树的结构。通过对根节点进行哈希，我们可以获得整个数据集的唯一标识，实现高效的数据验证。  

&ensp;&ensp;&ensp;&ensp;详细解释一下，MPT在前缀树的基础上，对每个节点进行哈希，即每个节点是它所有子节点的哈希值（`hash（child1，child2，...））`，用来索引数据库和计算根节点。其索引使用了两个类型的键：前缀树的key以及默克尔树所使用的key。  

## 3.MPT结构和操作原理  

### 3.1 节点类型  

&ensp;&ensp;&ensp;&ensp;Merkle Patricia Trie由四种类型的节点组成：  

+ **空节点（Null Node）**：空节点表示空值，并不存储任何信息。  
+ **分支节点（Branch Node）**  
&ensp;&ensp;&ensp;&ensp;分支节点用来表示MPT树中所有拥有超过1个child节点以上的非叶子节点。分支节点包含一个长度为17的数组，每个数组元素对应一个可能的子节点或空值。它用于扩展树的深度并存储子节点，其定义如下所示：  

```
type fullNode struct {
        Children [17]node // Actual trie node data to encode/decode (needs custom encoder)
        flags    nodeFlag
}
// nodeFlag contains caching-related metadata about a node.
type nodeFlag struct {
    hash  hashNode // cached hash of the node (may be nil)
    gen   uint16   // cache generation counter
    dirty bool     // whether the node has changes that must be written to the database
}
```
&ensp;&ensp;&ensp;&ensp;根据类型不同，trie节点存储内容有稍许不同，通常会包含`header、trie`路径的部分`key、children`节点以及`value`。与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大，因此进行树操作之前，首先会进行一个key编码的转换，将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，key的每一位的值范围都在`[0, 15]`内。因此，一个分支节点的孩子至多只有16个。这种方式减小了每个分支节点的容量，但是在一定程度上增加了树高。分支节点的孩子列表中，最后一个元素是用来存储自身的内容。  

&ensp;&ensp;&ensp;&ensp;此外，每个分支节点会有一个附带的字段nodeFlag，记录了一些辅助数据：  
&ensp;&ensp;&ensp;&ensp;**节点哈希**：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；  
&ensp;&ensp;&ensp;&ensp;**脏标志**：当一个节点被修改时，该标志位被置为1；  
&ensp;&ensp;&ensp;&ensp;**诞生标志**：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多；  

+ **扩展节点（Extension Node）**  

&ensp;&ensp;&ensp;&ensp;扩展节点用于共享子节点的公共前缀。它包含一个编码过的共同前缀和一个指向下一个节点的指针。  

+ **叶子节点（Leaf Node）**  

&ensp;&ensp;&ensp;&ensp;叶子节点存储一个键值对的哈希，其中键被编码为一个路径。其定义与扩展节点相似，其中关键的字段为：  
&ensp;&ensp;&ensp;&ensp;`Key：用来存储属于该节点范围的key；`  
&ensp;&ensp;&ensp;&ensp;`Val：用来存储该节点的内容；`  
&ensp;&ensp;&ensp;&ensp;使用前缀树会出现严重的存储空间浪费的的情况，如下图所示：  

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/11f15ce8-eb7f-439c-91a2-9ad5c7b5b3fb)

&ensp;&ensp;&ensp;&ensp;右侧出现过长的子节点，它们均为非叶子节点，且仅为构建一条路径。对于此类浪费，MPT作出了优化：当插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把剩余的Key存储在叶子／扩展节点的Key字段中，充当一个`“Shortcut”`。例如下图中我们将红线所圈的节点称为`node1`, 将紫色线所圈的节点称为`node2`。`node1`与`node2`共享路径前缀t，但是`node1`在插入时，树中没有与oast有共同前缀的路径，因此`node1`的key为oast，实现了编码路径的压缩。  

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/20e3d930-6eb2-40eb-8ee9-cc1c7970e15b)

&ensp;&ensp;&ensp;&ensp;这种做法有以下两点优势：  
    
        提高节点的查找效率，避免过多的磁盘访问；  
        减少存储空间浪费，避免存储无用的节点。  

### 3.2 编码和哈希  

&ensp;&ensp;&ensp;&ensp;在MPT中，键值对的键通过特定的编码方式转换为路径。这种编码通常使用RLP`（Recursive Length Prefix）`编码，它是一种递归前缀长度编码，用于将数据结构序列化。通过将键编码为路径，相似的键能够共享前缀，从而实现高效的存储。  

&ensp;&ensp;&ensp;&ensp;为了提高安全性和数据完整性，MPT中的每个节点都被哈希。节点的哈希值是通过将节点的内容（编码后的键、值或子节点哈希）与加密哈希函数（如`SHA-256`）进行哈希得到。节点的哈希用于验证节点的内容是否被篡改。  

### 3.3 具体操作  

#### 3.3.1 Get  

&ensp;&ensp;&ensp;&ensp;一次Get操作的过程为：  

* 将需要查找Key的Raw编码转换成Hex编码，得到的内容称之为搜索路径；  
* 从根节点开始搜寻与搜索路径.  

&ensp;&ensp;&ensp;&ensp;其中**搜索过程**：

```
① 如果当前节点是叶节点，则存储的内容是数据元素的内容，并且搜索路径的内容与叶节点的关键字相同，然后查找节点。相反，它表示树中不存在节点。  
② 如果当前节点是扩展节点，存储的内容是哈希索引，则哈希索引用于从数据库加载节点，然后搜索路径用作参数，递归调用搜索函数以分析新节点。  
③ 如果当前节点是扩展节点，则存储的内容是对另一个节点的引用，当前节点的键是搜索路径的前缀，然后通过从当前节点中减去键来搜索路径，其余的以搜索路径作为参数，搜索函数通常调用子节点。如果当前节点的键不是搜索路径的前缀，则表示该节点不在树中。  
④ 如果当前节点是分支节点，如果搜索路径为空，则返回分支节点的存储内容。相反，搜索路径的第一个字节用于识别分支节点的子节点，其余的搜索路径用作参数，递归地调用搜索函数。  
```

&ensp;&ensp;&ensp;&ensp;**下图是一次查找key为“cat”节点的过程。** 

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/9ccf7da2-2f35-452f-9d6d-e34b0e63d379)

* 将cat转换成hex编码[3,15,3,13,4,10,T] （在末尾添加终止符是因为需要查找一个真实的数据项内容）；  
* 当前节点是根节点，且是扩展节点，其key为3,15，则递归地对其子节点进行查找调用，剩余的搜索路径为[3,13,4,10,T];  
* 当前节点是分支节点，以搜索路径的第一个字节内容3选择第4个孩子节点递归进行查找，剩余的搜索路径为[13,4,10,T]；  
* 当前节点是叶子节点，且key与剩余的搜索路径一致，表示找到了该节点，返回Val为dog。 


#### 3.3.2 插入  

&ensp;&ensp;&ensp;&ensp;插入操作也是基于查找过程完成的，一个插入过程为：  

&ensp;&ensp;&ensp;&ensp;**① 首先找到与新插入节点拥有最长相同路径前缀的节点，记为Node；**  
&ensp;&ensp;&ensp;&ensp;**若该Node为分支节点：**  
* 剩余的搜索路径不为空，则将新节点作为一个叶子节点插入到对应的孩子列表中；  
* 剩余的搜索路径为空（完全匹配），则将新节点的内容存储在分支节点的第17个孩子节点项中（Value）；
    
&ensp;&ensp;&ensp;&ensp;**若该节点为叶子／扩展节点：**  
* 剩余的搜索路径与当前节点的key一致，则把当前节点Val更新即可；  
* 剩余的搜索路径与当前节点的key不完全一致，则将叶子／扩展节点的孩子节点替换成分支节点，将新节点与当前节点key的共同前缀作为当前节点的key，将新节点与当前节点的孩子节点作为两个孩子插入到分支节点的孩子列表中，同时当前节点转换成了一个扩展节点（若新节点与当前节点没有共同前缀，则直接用生成的分支节点替换当前节点）；  

&ensp;&ensp;&ensp;&ensp;**② 若插入成功**，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在。  

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/0f29351d-7a68-478a-bb91-6c454ae4af3b)

&ensp;&ensp;&ensp;&ensp;上图是一次将**key**为“**cau**”, **value**为“**dog1**”节点插入的过程。  
* 将key"cau"转换成hex编码[3,15,3,13,4,11,T] ；  
* 通过查找算法，找到左图蓝线圈出的节点node1，且拥有与新插入节点最长的共同前缀[3,15,3,13,4]；  
* 新增一个分支节点node2，将node1的val与新节点作为孩子插入到node2的孩子列表中，将node1的val替换成node2；  
* node1变成了一个扩展节点。  

#### 3.3.3 删除  

&ensp;&ensp;&ensp;&ensp;删除操作与插入操作类似，都需要借助查找过程完成，在此不详细描述，仅以下图将**key**为“**cau**”, **value**为“**dog1**”节点删除的过程为例：  

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/5ffbb5da-ea33-43fe-bf9e-f79814ea95e0)

![image](https://github.com/xinxingroup32num1/homework-group-32/assets/138662552/84443736-15d0-4515-8079-79d26e2e7d72)

* 将key"cau"转换成hex编码[3,15,3,13,4,11,T] ；  
* 通过查找算法，找到用叉表示的节点node1，从根节点到node1的路径与搜索路径完全一致；  
* 从node1的父节点中删除该节点，父节点仅剩一个孩子节点，故将父节点转换成一个叶子节点；  
* 新生成的叶子节点又与其父节点（扩展节点）发生了合并，最终生成了一个叶子节点包含了所有的信息。  

## 4.MPT在区块链中的应用  

### 4.1 以太坊中的MPT  

&ensp;&ensp;&ensp;&ensp;MPT作为一种高效的数据结构，在区块链中扮演着重要的角色，为数据存储和验证提供了强大的支持。在区块链领域的最典型应用是在以太坊区块链中。以太坊是一种开源的去中心化智能合约平台，通过智能合约实现去中心化应用的开发和执行。在以太坊中，MPT被用来存储账户状态树和交易信息。  
&ensp;&ensp;&ensp;&ensp;**账户状态树**：以太坊中的账户状态树记录着所有账户的状态信息，包括账户余额、合约代码、合约存储等。每个账户都有一个唯一的地址，由公钥经过哈希得到。MPT的结构和操作原理使得在更新账户状态时，只需对发生变化的节点进行修改，而无需修改整个树，从而提高了状态更新的效率。  
&ensp;&ensp;&ensp;&ensp;**交易存储**：以太坊中的交易也被存储在MPT中。每个区块都包含一系列交易，通过MPT存储，使得可以方便地验证交易的有效性和完整性。由于MPT的特性，相同的交易在不同区块中可以共享相同的前缀路径，从而降低了存储成本。  

### 4.2 区块链状态存储  

&ensp;&ensp;&ensp;&ensp;除了以太坊，其他一些区块链平台也采用了MPT作为状态存储的数据结构。区块链的状态存储包含着所有账户的当前状态信息，包括余额、权限和合约状态等。MPT的高效存储和验证特性使得区块链能够更快地处理账户状态的更新和数据验证。  

### 4.3 交易存储  

&ensp;&ensp;&ensp;&ensp;区块链中的交易通常也被存储在MPT中。通过将交易存储在MPT中，可以快速验证交易的有效性，并确保交易数据的完整性。这对于分布式系统来说是非常重要的，因为它能够防止无效或恶意的交易被执行。  

### 4.4 其他应用领域  

&ensp;&ensp;&ensp;&ensp;除了在区块链中的应用，MPT的结构和操作原理也适用于其他分布式数据库和存储系统。它可以用于加快数据访问速度、提高数据完整性和验证性能，并节省存储空间和计算成本。在去中心化应用和分布式系统中，MPT作为高效数据结构的选择，有着广泛的应用前景。  

## 5.MPT的优势和挑战  

### 5.1 优势  

&ensp;&ensp;&ensp;&ensp;**高效存储**：Merkle Patricia Trie的结构使得相似的键能够共享前缀路径，从而在存储大量数据时实现了较高的压缩比率。相比传统的数据结构，MPT能够节省大量存储空间。  
&ensp;&ensp;&ensp;&ensp;**快速验证**：MPT的哈希结构使得通过验证根节点的哈希值就可以高效地验证整个数据集的完整性和正确性。在区块链中，这对于确保交易和状态的安全至关重要。  
&ensp;&ensp;&ensp;&ensp;**高效操作**：MPT的插入和删除操作都是基于节点的哈希值进行的，因此只需要更新路径上的节点。这使得对数据的修改操作非常高效，尤其是在区块链中需要频繁更新账户状态和交易信息的场景。  
&ensp;&ensp;&ensp;&ensp;**分布式支持**：MPT的结构天然适合在分布式系统中使用。每个节点只需存储其本地数据的部分MPT结构，从而实现了分布式数据存储和验证的支持。  

### 5.2 挑战  

&ensp;&ensp;&ensp;&ensp;**写入性能**：虽然MPT在读取和验证数据方面表现优异，但在频繁的写入场景下，由于需要更新路径上的节点，写入性能可能受到一定影响。在一些高频交易的区块链平台中，需要特别注意这一点。 
 
&ensp;&ensp;&ensp;&ensp;**存储成本**：尽管MPT通过压缩路径共享前缀来降低存储空间，但在一些大规模的区块链系统中，仍然需要考虑到存储成本的问题，尤其是在数据规模不断增长的情况下。  

&ensp;&ensp;&ensp;&ensp;**长期演进**：MPT作为一种数据结构，可能会面临技术的不断演进和改进。随着区块链和分布式系统的发展，MPT需要不断适应新的需求和挑战，可能需要进行优化和改进。 
 
&ensp;&ensp;&ensp;&ensp;**同步和一致性**：在分布式系统中，节点之间的同步和一致性是一项复杂的任务。确保每个节点都具有正确的MPT结构并保持一致性可能需要一些额外的机制和协议。  

## 6.未来展望  

&ensp;&ensp;&ensp;&ensp;未来，在面对大规模数据和高频写入场景时，进一步优化MPT的性能是一个重要的研究方向，可能通过改进写入路径、压缩算法和节点更新策略等来提高MPT的写入性能；同时随着区块链和分布式系统的广泛应用，高并发支持成为一个关键挑战，未来的研究可以集中在如何优化MPT在多节点同时写入和验证的情况下的性能表现；随着数据规模不断增长，如何保持MPT的可扩展性也是一个重要问题。研究人员可以探索分布式MPT和分片MPT等方法来实现更高的可扩展性；此外，MPT在数据验证和完整性方面表现出色，但随着量子计算等技术的发展，未来可能需要考虑对MPT的安全性进行加固，以应对潜在的安全风险。  

## 7.结论  

&ensp;&ensp;&ensp;&ensp;MPT作为Merkle树和Patricia Trie的结合体，在区块链和分布式数据库等领域展现了强大的优势。它通过高效存储、快速验证和分布式支持，为区块链技术的发展提供了坚实的基础。MPT在以太坊等智能合约平台中的应用充分证明了它的可行性和效用。  
&ensp;&ensp;&ensp;&ensp;然而，MPT也面临着一些挑战，包括写入性能、存储成本和长期演进等问题。未来的研究和改进可以着重解决这些挑战，以进一步提升MPT的性能和可靠性。  
&ensp;&ensp;&ensp;&ensp;总体而言，MPT作为一种高效的数据结构，具有广阔的应用前景。在未来的发展中，我们有理由相信MPT将继续在区块链和分布式系统中发挥重要作用，并为数据存储和验证领域的研究和应用做出更多的贡献。  

## 参考资料  

【1】[Blockchain-for-Developers/merkle-tree： Merkle Tree Implementation for Lab07 (github.com)]()  
【2】[前缀树(字典树）_小轩爱学习的博客-CSDN博客_前缀树和字典树]()  
【3】[MPT详解_区块链mpt_yitahutu79的博客-CSDN博客]()  
【4】[1_merkle-tree-master.rar-网络攻防文档类资源-CSDN文库]()
